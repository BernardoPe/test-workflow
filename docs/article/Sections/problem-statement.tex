\section{Problem Statement}

In this section we discuss the problems associated with progressive server-side
rendering (PSSR) in modern web applications, focusing on the challenges and
limitations of existing approaches. We then present the objective of our work,
which aims to increase the available options for PSSR in web applications,
particularly in the context of JVM based frameworks.

\textit As we outlined in the previous section, \textit{external} DSLs for HTML such as Thymeleaf, Jstachio, Handlebars, and others define HTML
templates within HTML documents with markers specific to the engine. Template engines that use \textit{internal} DSLs, such as KotlinX or HtmlFlow,
define the HTML templates in the programming language itself, leveraging the language's
syntax and features to create the templates.

\textit{Internal} DSLs can more easily support asynchronous data models since
they can leverage the language's existing features and libraries, thus enabling
the progressive streaming of HTML content to the client, with \textit{external}
DSLs supporting simpler blocking data models such as \texttt{Iterable} or
\texttt{List}. While on the previous section we outlined several advantages of
using \textit{internal} DSLs over textual templates for HTML, there are also
advantages to using \textit{external} DSLs:

\begin{enumerate}
    \item \emph{Separation of Concerns}: \textit{External} DSLs allow for a clear separation between
          the HTML structure and the application logic, making it easier to maintain and update
          templates without modifying the underlying code. This ''
          separation'' can be beneficial, as it allows front-end developers to work on the HTML
          templates without needing to understand the underlying application logic or programming language.
    \item \emph{Cross-Language Compatibility}: \textit{External} DSLs can be used across different programming languages
          and frameworks, making them more versatile and easier to integrate into existing projects.
          This is particularly useful in environments where multiple languages are used.
    \item \emph{Familiarity}: Many developers are already familiar with HTML and its syntax, making
          it easier to work with \textit{external} DSLs that use HTML-like syntax.
\end{enumerate}

Due to these advantages, many developers prefer to use \textit{external} DSLs
for HTML templates, even if it means sacrificing some of the advantages of
using \textit{internal} DSLs. However, this preference can lead to challenges
when it comes to progressive server-side rendering (PSSR) and non-blocking I/O,
as many \textit{external} DSLs do not support asynchronous data models.

\autoref{lst:presentation-jstachio} shows the HTML template for a \texttt{Presentation} class using the JStachio template engine, 
while \autoref{lst:presentation-htmlflow} presents the equivalent template using HtmlFlow.

\lstset{style=listingstyle}
\begin{lstlisting}[
  language=Kotlin,
  numbers=none,
  basicstyle=\scriptsize\ttfamily,
  caption={Presentation HTML template using \textit{JStachio}}
  label={lst:presentation-jstachio}
]
<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-compatible" content="IE=Edge">
    <title>
        JFall 2013 Presentations - JStachio
    </title>
    <link rel="Stylesheet" href="/webjars/bootstrap/5.3.0/css/bootstrap.min.css">
</head>
<body>
<div class="container">
    <div class="pb-2 mt-4 mb-3 border-bottom">
        <h1>
            JFall 2013 Presentations - JStachio
        </h1>
    </div>
    {{#presentationItems}}
    <div class="card mb-3 shadow-sm rounded">
        <div class="card-header">
            <h5 class="card-title">
                {{title}} - {{speakerName}}
            </h5>
        </div>
        <div class="card-body">
            {{summary}}
        </div>
    </div>
    {{/presentationItems}}
</div>
</body>
</html>
\end{lstlisting}
\vspace{0.5cm}
\begin{lstlisting}[
  language=Kotlin,
  numbers=none,
  basicstyle=\scriptsize\ttfamily,
  caption={Presentation HTML template using \textit{HtmlFlow}}
  label={lst:presentation-htmlflow}
]
 val htmlFlowTemplate: HtmlViewAsync<Observable<Presentation>> =
    HtmlFlow.viewAsync<Observable<Presentation>?> { view ->
        view.html {
            attrLang("en-us")
            head {
                meta { attrCharset("UTF-8") }
                meta { attrName("viewport").attrContent("width=device-width, initial-scale=1.0") }
                meta { addAttr("http-equiv", "X-UA-Compatible").attrContent("IE=Edge") }
                title { text("JFall 2013 Presentations - HtmlFlow") }
                link { attrRel(EnumRelType.STYLESHEET).attrHref("/webjars/bootstrap/5.3.0/css/bootstrap.min.css") }
            }
            body {
                div {
                    attrClass("container")
                    div {
                        attrClass("pb-2 mt-4 mb-3 border-bottom")
                        h1 { text("JFall 2013 Presentations - HtmlFlow") }
                    }
                    await { div, model: Observable<Presentation>, onCompletion ->
                        model
                            .doOnNext { 
                                presentationFragmentAsync
                                    .renderAsync(it)
                                    .thenApply { frag -> div.raw(frag) }
                            }
                            .doOnComplete { onCompletion.finish() }
                            .subscribe()
                    }
                }
            }
        }
    }.threadSafe()
\end{lstlisting}
\lstset{style=listingstyle}

HtmlFlow is an example of an \textit{internal} DSL that uses calls to HTML
builders as a way to emit HTML\@. It allows for the use of the
\texttt{Observable} class as a data model, which in turn allows for the definition of a
\texttt{Consumer<Presentation>} through the \texttt{doOnNext} method. Every
time a new value is emitted to the \texttt{Observable}, the \texttt{doOnNext}
method is called, emitting the HTML fragment for the \texttt{Presentation}
object to the client.

The Jstachio template engine, on the other hand, uses an \textit{external} DSL,
where the HTML template is defined in a separate file. The template engine uses
the \texttt{presentationItems} variable to define the data model, which is a
list of \texttt{Presentation} objects. This allows the template engine to
iterate over the list of \texttt{Presentation} objects and render the HTML for
each one.

As demonstrated, the HtmlFlow template enables PSSR by directly supporting the
use of the \texttt{Observable} class as a data model. However, not all
programmers are familiar with asynchronous programming models, which can make
implementing this solution challenging. In contrast, Jstachio defines templates
using standard HTML syntax with specific tags for the template engine,
resulting in a simpler and more accessible template definition. However,
because Jstachio templates rely on an \texttt{Iterable} interface,
they block the calling thread until the entire HTML content is rendered and
therefore do not support non-blocking PSSR\@.

% Mencionar que certas DSLs internas n√£o suportam PSSR por 
% causa de HTML mal formado? (KotlinX)

In previous work \cite{PSSR-WISE2024}, Carvalho developed a benchmark
using Spring Webflux to evaluate the performance of HtmlFlow with suspendable
web templates. In this benchmark, HtmlFlow's performance was compared to that
of Thymeleaf using a reactive approach, as well as other template engines such
as the one shown in \autoref{lst:presentation-JStachio}. The results
demonstrated that HtmlFlow scaled efficiently up to 128 concurrent users,
achieving a throughput of up to 4,000 requests per second. In contrast, the
blocking template engines ceased to scale beyond 4 concurrent users, reaching a
maximum throughput of approximately 400 requests per second. These findings
indicate that engines which block the calling thread scale poorly and are not
suitable for PSSR\@.

% Expandir sobre virtual threads aqui?
With the advent of Java 21 and the introduction of \textit{Virtual Threads}, it
is now possible to execute code that would otherwise block the calling thread
in a scalable, non-blocking manner. This advancement enables the use of these
\textit{external} DSLs in non-blocking contexts. The objective of this work is
to evaluate the performance of these template engines when leveraging Virtual
Threads, and to determine whether they can be made viable for PSSR\@. We will
also compare the performance of this approach with existing solutions based on
reactive programming and Kotlin coroutines.

If the performance of these engines proves comparable to that of current
approaches, it would enable PSSR to be implemented using more familiar HTML
syntax, simplifying template development and adoption. Furthermore, template
engine developers seeking to support PSSR would no longer need to implement
complex asynchronous programming models to achieve non-blocking I/O; instead,
they could rely on the traditional approaches used for Server Side Rendering
(SSR).